
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Absurdity and Farce</title>
  <meta name="author" content="Bret McGuire">

  
  <meta name="description" content="Originally published at Heuristic Fencepost Suppose that you&#8217;ve just finished Graham Hutton&#8217;s solid introduction to Haskell and now want &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://absurdfarce.github.com/blog/page/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Absurdity and Farce" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Absurdity and Farce</a></h1>
  
    <h2>Searching for the sublime among the ridiculous</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:absurdfarce.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/12/20/a-funny-thing-happened-while-writing-some-haskell/">A Funny Thing Happened While Writing Some Haskell&#8230;.</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-12-20T12:00:00-06:00" pubdate data-updated="true">Dec 20<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Originally published at <a href="http://heuristic-fencepost.blogspot.com/2010/12/funny-thing-happened-while-writing-some.html">Heuristic Fencepost</a></p>

<p>Suppose that you&#8217;ve just finished Graham Hutton&#8217;s solid <a href="http://www.cs.nott.ac.uk/~gmh/book.html">introduction</a> to Haskell and now want to take the language for a quick test drive. You decide to stick with something familiar; after noting that the Prelude doesn&#8217;t have an equivalent to Python&#8217;s <a href="http://docs.python.org/2/library/functions.html#range">range</a> function you decide to whip one up yourself. Haskell&#8217;s syntax is still a bit unfamiliar, however, so you decide to implement this function in a different &#8220;mostly functional&#8221; language that you have some experience with. You&#8217;ve been looking for a reason to dip your toes into Scheme again (and it seems to be a good fit here [1]) so you install <a href="http://dynamo.iro.umontreal.ca/wiki/index.php/Main_Page">Gambit Scheme</a> and <a href="http://www.call-cc.org">Chicken Scheme</a> and dig in.</p>

<p>Perhaps you begin with a straightforward recursive definition in Scheme:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">range</span> <span class="nv">start</span> <span class="nv">stop</span> <span class="nv">step</span><span class="p">)</span>
</span><span class='line'> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">start</span> <span class="nv">stop</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">cons </span><span class="nv">start</span> <span class="p">(</span><span class="nf">range</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">start</span> <span class="nv">step</span><span class="p">)</span> <span class="nv">stop</span> <span class="nv">step</span><span class="p">))</span>
</span><span class='line'>  <span class="o">&#39;</span><span class="p">()))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This works well enough when start &lt; stop but fails completely when start > stop and step is a negative value (a use case supported by Python&#8217;s range()). To fix this problem we define two procedures via letrec and use whichever is appropriate based on the passed arguments:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">newrange</span> <span class="nv">start</span> <span class="nv">stop</span> <span class="nv">step</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="k">letrec </span>
</span><span class='line'>   <span class="p">((</span><span class="nf">upto</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">art</span> <span class="nv">op</span> <span class="nv">ep</span><span class="p">)</span>
</span><span class='line'>     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">art</span> <span class="nv">op</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">cons </span><span class="nv">art</span> <span class="p">(</span><span class="nf">upto</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">art</span> <span class="nv">ep</span><span class="p">)</span> <span class="nv">op</span> <span class="nv">ep</span><span class="p">))</span>
</span><span class='line'>      <span class="o">&#39;</span><span class="p">())))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">downto</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">art</span> <span class="nv">op</span> <span class="nv">ep</span><span class="p">)</span>
</span><span class='line'>     <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">art</span> <span class="nv">op</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">cons </span><span class="nv">art</span> <span class="p">(</span><span class="nf">downto</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">art</span> <span class="nv">ep</span><span class="p">)</span> <span class="nv">op</span> <span class="nv">ep</span><span class="p">))</span>
</span><span class='line'>      <span class="o">&#39;</span><span class="p">()))))</span>
</span><span class='line'> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">start</span> <span class="nv">stop</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">upto</span> <span class="nv">start</span> <span class="nv">stop</span> <span class="nv">step</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">downto</span> <span class="nv">start</span> <span class="nv">stop</span> <span class="nv">step</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This function now works for both start &lt; stop (with positive step) and start > stop (with negative step). There&#8217;s still a problem, though; if we change the sign of step in either of these cases we find ourselves in an infinite loop. Python&#8217;s range() returns an empty list in this case so we probably should too:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scheme'><span class='line'><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">newerrange</span> <span class="nv">start</span> <span class="nv">stop</span> <span class="nv">step</span><span class="p">)</span>
</span><span class='line'> <span class="p">(</span><span class="nf">letrec</span>
</span><span class='line'>  <span class="p">((</span><span class="nf">upto</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">art</span> <span class="nv">op</span> <span class="nv">ep</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">art</span> <span class="nv">op</span><span class="p">)</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">cons </span><span class="nv">art</span> <span class="p">(</span><span class="nf">upto</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">art</span> <span class="nv">ep</span><span class="p">)</span> <span class="nv">op</span> <span class="nv">ep</span><span class="p">))</span>
</span><span class='line'>     <span class="o">&#39;</span><span class="p">())))</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">downto</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">art</span> <span class="nv">op</span> <span class="nv">ep</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">art</span> <span class="nv">op</span><span class="p">)</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">cons </span><span class="nv">art</span> <span class="p">(</span><span class="nf">downto</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">art</span> <span class="nv">ep</span><span class="p">)</span> <span class="nv">op</span> <span class="nv">ep</span><span class="p">))</span>
</span><span class='line'>     <span class="o">&#39;</span><span class="p">()))))</span>
</span><span class='line'>    <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">start</span> <span class="nv">stop</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt; </span><span class="nv">step</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class='line'>          <span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">start</span> <span class="nv">stop</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt; </span><span class="nv">step</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class='line'>          <span class="p">((</span><span class="nb">&lt; </span><span class="nv">start</span> <span class="nv">stop</span><span class="p">)</span> <span class="p">(</span><span class="nf">upto</span> <span class="nv">start</span> <span class="nv">stop</span> <span class="nv">step</span><span class="p">))</span>
</span><span class='line'>          <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">downto</span> <span class="nv">start</span> <span class="nv">stop</span> <span class="nv">step</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>While working on these implementations you discover that SRFI-1 includes a function iota which looks similar to Python&#8217;s range(), although this function takes the number of elements in the return list rather than the start/stop/step values we&#8217;re looking for. Still, both Chicken Scheme and Gambit Scheme support SFRI-1 as extensions or modules and we should be able to whip up a thin wrapper around iota to get what we need. Of course we first need to figure out how to load up these modules. And after some initial experimentation we see some curious behaviour in the iota implementation on both platforms&#8230;</p>

<p>But wait&#8230; weren&#8217;t we supposed to be writing some Haskell code?</p>

<p>Oh, yeah.</p>

<p>Haskell&#8217;s guarded equations allow for an easy expression of the same logic we were getting from cons in Scheme. We have no need to translate the recursive logic found in the Scheme version, however, since the list-related functions in the Prelude combined with a few sections gives us everything we need:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">range</span> <span class="n">art</span> <span class="n">op</span> <span class="n">ep</span> <span class="o">|</span> <span class="n">art</span> <span class="o">&lt;</span> <span class="n">op</span> <span class="o">&amp;&amp;</span> <span class="n">ep</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'>                <span class="o">|</span> <span class="n">art</span> <span class="o">&gt;</span> <span class="n">op</span> <span class="o">&amp;&amp;</span> <span class="n">ep</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">[]</span>
</span><span class='line'>                <span class="o">|</span> <span class="n">art</span> <span class="o">&lt;</span> <span class="n">op</span> <span class="ow">=</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">op</span><span class="p">)</span> <span class="p">(</span><span class="n">iterate</span> <span class="p">(</span><span class="o">+</span><span class="n">ep</span><span class="p">)</span> <span class="n">art</span><span class="p">)</span>
</span><span class='line'>                <span class="o">|</span> <span class="n">art</span> <span class="o">&gt;</span> <span class="n">op</span> <span class="ow">=</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&gt;</span><span class="n">op</span><span class="p">)</span> <span class="p">(</span><span class="n">iterate</span> <span class="p">(</span><span class="o">+</span><span class="n">ep</span><span class="p">)</span> <span class="n">art</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>In all honesty this is a fairly elegant expression of the algorithm. And while there&#8217;s clearly a lot to like in Haskell this exercise has rekindled a long-dormant romance with Scheme rather than encouraging exploration of something new.</p>

<p>[1] Yes, I realize Scheme isn&#8217;t &#8220;purely functional&#8221;. I&#8217;m not interested in taking a stand in this particular holy war, but there&#8217;s little doubt that Scheme&#8217;s bias against set! and it&#8217;s kin justify the &#8220;mostly functional&#8221; qualifier.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/31/base64-in-clojure-an-initial-attempt/">Base64 in Clojure: An Initial Attempt</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-31T12:00:00-05:00" pubdate data-updated="true">Oct 31<span>st</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Originally published at <a href="http://heuristic-fencepost.blogspot.com/2010/10/base64-in-clojure-initial-attempt.html">Heuristic Fencepost</a></p>

<p>After working through most of Stuart Halloway&#8217;s excellent <a href="http://pragprog.com/book/shcloj/programming-clojure">Programming Clojure</a> I found myself in search of a meaty example to exercise my Clojure chops. Re-implementing the Project Euler examples in another language didn&#8217;t seem terribly appealing. Maybe a base64 implementation; I hadn&#8217;t implemented the encoding in a while and it is a reasonable exercise when learning a new language. So what kind of support does Clojure already have?</p>

<p>As expected there&#8217;s no base64 support in the core. clojure-contrib does include <a href="http://richhickey.github.io/clojure-contrib/base64-api.html">some support</a>, although the documentation doesn&#8217;t inspire a great deal of confidence:</p>

<pre><code>This is mainly here as an example.  It is much slower than the 
Apache Commons Codec implementation or sun.misc.BASE64Encoder.
</code></pre>

<p>Intriguing; looks like we have a winner!</p>

<p>The only complexity in a base64 implementation is handling the one and two byte cases. Any code must support returning the last two bits of the first byte (or the last four bits of the second byte) as distinct values in these cases as well as combining these bits with the leading bits of the second and third bytes (respectively) in other cases. My initial implementation was a fairly straightforward adaptation of this principle.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">ns </span><span class="nv">fencepost.base64_letfn</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">; This could be placed within the defn below but rebuilding this map</span>
</span><span class='line'><span class="c1">; on each invocation seems a bit wasteful.</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">to-base64</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">zipmap </span>
</span><span class='line'>      <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">64</span><span class="p">)</span>
</span><span class='line'>      <span class="s">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><span class="p">)</span>
</span><span class='line'>     <span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">base64-encode</span>
</span><span class='line'>  <span class="s">&quot;Encode input string into base64 alphabet.  String should be encoded</span>
</span><span class='line'><span class="s">  in the character set specified by encoding.&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="o">#^</span><span class="nv">String</span> <span class="nv">arg</span> <span class="o">#^</span><span class="nv">String</span> <span class="nv">encoding</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">letfn</span> <span class="p">[</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">do-one-byte</span> <span class="p">[</span><span class="nv">somebyte</span><span class="p">]</span>
</span><span class='line'>                   <span class="p">{</span><span class="ss">:curr</span> <span class="p">[(</span><span class="nb">bit-shift-right </span><span class="nv">somebyte</span> <span class="mi">2</span><span class="p">)]</span> <span class="ss">:remainder</span> <span class="p">(</span><span class="nb">bit-and </span><span class="mi">0</span><span class="nv">x3F</span> <span class="p">(</span><span class="nb">bit-shift-left </span><span class="nv">somebyte</span> <span class="mi">4</span><span class="p">))</span> <span class="p">}</span>
</span><span class='line'>                   <span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">do-two-bytes</span> <span class="p">[</span><span class="nv">somebytes</span><span class="p">]</span>
</span><span class='line'>                    <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">byteone</span> <span class="nv">bytetwo</span><span class="p">]</span> <span class="nv">somebytes</span>
</span><span class='line'>                          <span class="p">{</span><span class="nv">curr</span> <span class="ss">:curr</span> <span class="nv">remainder</span> <span class="ss">:remainder</span><span class="p">}</span> <span class="p">(</span><span class="nf">do-one-byte</span> <span class="nv">byteone</span><span class="p">)]</span>
</span><span class='line'>                      <span class="p">{</span><span class="ss">:curr</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">curr</span> <span class="p">(</span><span class="nb">bit-or </span><span class="nv">remainder</span> <span class="p">(</span><span class="nb">bit-shift-right </span><span class="nv">bytetwo</span> <span class="mi">4</span><span class="p">)))</span> <span class="ss">:remainder</span> <span class="p">(</span><span class="nb">bit-and </span><span class="mi">0</span><span class="nv">x3F</span> <span class="p">(</span><span class="nb">bit-shift-left </span><span class="nv">bytetwo</span> <span class="mi">2</span><span class="p">))}</span>
</span><span class='line'>                      <span class="p">)</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">do-three-bytes</span> <span class="p">[</span><span class="nv">somebytes</span><span class="p">]</span>
</span><span class='line'>                      <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">byteone</span> <span class="nv">bytetwo</span> <span class="nv">bytethree</span><span class="p">]</span> <span class="nv">somebytes</span>
</span><span class='line'>                            <span class="p">{</span><span class="nv">curr</span> <span class="ss">:curr</span> <span class="nv">remainder</span> <span class="ss">:remainder</span><span class="p">}</span> <span class="p">(</span><span class="nf">do-two-bytes</span> <span class="p">[</span><span class="nv">byteone</span> <span class="nv">bytetwo</span><span class="p">])]</span>
</span><span class='line'>                        <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">conj </span><span class="nv">curr</span> <span class="p">(</span><span class="nb">bit-or </span><span class="nv">remainder</span> <span class="p">(</span><span class="nb">bit-shift-right </span><span class="nv">bytethree</span> <span class="mi">6</span><span class="p">)))</span> <span class="p">(</span><span class="nb">bit-and </span><span class="mi">0</span><span class="nv">x3F</span> <span class="nv">bytethree</span><span class="p">))</span>
</span><span class='line'>                        <span class="p">)</span>
</span><span class='line'>                      <span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">somefn</span> <span class="p">[</span><span class="nv">somechars</span><span class="p">]</span>
</span><span class='line'>                <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">l</span> <span class="p">(</span><span class="nb">count </span><span class="nv">somechars</span><span class="p">)]</span>
</span><span class='line'>                  <span class="p">(</span><span class="nf">cond</span>
</span><span class='line'>                   <span class="p">(</span><span class="nb">= </span><span class="nv">l</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">to-base64</span> <span class="nv">%</span><span class="p">)</span> <span class="p">(</span><span class="nf">do-three-bytes</span> <span class="nv">somechars</span><span class="p">)))</span>
</span><span class='line'>                   <span class="p">(</span><span class="nb">= </span><span class="nv">l</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="nv">curr</span> <span class="ss">:curr</span> <span class="nv">remainder</span> <span class="ss">:remainder</span><span class="p">}</span> <span class="p">(</span><span class="nf">do-two-bytes</span> <span class="nv">somechars</span><span class="p">)]</span>
</span><span class='line'>                     <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">to-base64</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">curr</span><span class="p">))</span> <span class="p">(</span><span class="nf">to-base64</span> <span class="nv">remainder</span><span class="p">)</span> <span class="s">&quot;=&quot;</span><span class="p">)</span>
</span><span class='line'>                     <span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="nb">= </span><span class="nv">l</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>                   <span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="nv">curr</span> <span class="ss">:curr</span> <span class="nv">remainder</span> <span class="ss">:remainder</span><span class="p">}</span> <span class="p">(</span><span class="nf">do-one-byte</span> <span class="p">(</span><span class="nb">first </span><span class="nv">somechars</span><span class="p">))]</span>
</span><span class='line'>                     <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">to-base64</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">curr</span><span class="p">))</span> <span class="p">(</span><span class="nf">to-base64</span> <span class="nv">remainder</span><span class="p">)</span> <span class="s">&quot;==&quot;</span><span class="p">)</span>
</span><span class='line'>                     <span class="p">))))]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">apply str </span><span class="p">(</span><span class="nb">map </span><span class="nv">somefn</span> <span class="p">(</span><span class="nf">partition</span> <span class="mi">3</span> <span class="mi">3</span> <span class="p">()</span> <span class="p">(</span><span class="nf">.getBytes</span> <span class="nv">arg</span> <span class="nv">encoding</span><span class="p">))))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">base64-encode-ascii</span>
</span><span class='line'>  <span class="s">&quot;Encode input string into base64 alphabet.  Input string is assumed</span>
</span><span class='line'><span class="s">  to be encoded in UTF-8.  If the input is encoded with a different</span>
</span><span class='line'><span class="s">  character set base64-encode should be used instead of this method.&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="o">#^</span><span class="nv">String</span> <span class="nv">arg</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">base64-encode</span> <span class="nv">arg</span> <span class="s">&quot;UTF8&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The core consists of a letfn definition with functions for handling the one, two and three byte cases. Each function returns two values: a list of all 6-bit elements discovered so far as well a &#8220;remainder&#8221; value representing the trailing bits in the one and two byte cases. This structure leads to better function re-use; as an example the two-byte function can build on the one-byte function. A wrapper function calls the correct value for a given set of bytes. Now we need only partition our byte array into groups of three or less and apply the wrapper function to each group. A combination of the partition and map functions do exactly that.</p>

<p>So how&#8217;d we do? We implement a simple test program to generate a set of random data, map a base64 implementation on to each sample and then realize the lazy sequence by converting it into a vector. We time this conversion (for a common set of sample data) for our implementation, the clojure-contrib implementation and commons-codec. We wind up with the following:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">ns </span><span class="nv">fencepost.test</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">org.apache.commons.codec.binary</span> <span class="nv">Base64</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">org.apache.commons.lang</span> <span class="nv">RandomStringUtils</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="nf">use</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.contrib.base64</span><span class="p">])</span>
</span><span class='line'><span class="p">(</span><span class="nf">use</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">fencepost.base64_letfn</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">sample-size</span> <span class="mi">100</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">max-string-size</span> <span class="mi">256</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">; Build up some sample data using commons-lang.  Sample data is built</span>
</span><span class='line'><span class="c1">; before any tests are run; this allows us to apply uniform test data</span>
</span><span class='line'><span class="c1">; to each implementation and to avoid corrupting timings with the</span>
</span><span class='line'><span class="c1">; generation of random data.</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">sample-data</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">RandomStringUtils/randomAscii</span> <span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="p">(</span><span class="nb">rand-int </span><span class="nv">max-string-size</span><span class="p">)))</span> <span class="p">(</span><span class="nb">repeat </span><span class="nv">sample-size</span> <span class="mi">1</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">; Instantiate a Base64 instance from commons-codec</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">codec-base64</span> <span class="p">(</span><span class="k">new </span><span class="nv">Base64</span> <span class="mi">-1</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">; Time each run.  Mapping a function onto our sample data produces a</span>
</span><span class='line'><span class="c1">; lazy sequence so we have to take the additional step of realizing</span>
</span><span class='line'><span class="c1">; the sequence; thus the conversion to a vector.</span>
</span><span class='line'><span class="p">(</span><span class="nb">println </span><span class="s">&quot;Commons-codec&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">commons-codec-data</span> <span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="k">new </span><span class="nv">String</span> <span class="p">(</span><span class="nf">.encode</span> <span class="nv">codec-base64</span> <span class="p">(</span><span class="nf">.getBytes</span> <span class="nv">%</span><span class="p">)))</span> <span class="nv">sample-data</span><span class="p">))))</span>
</span><span class='line'><span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">get </span><span class="nv">commons-codec-data</span> <span class="mi">0</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nb">println </span><span class="s">&quot;clojure-contrib&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">clojure-contrib-data</span> <span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">clojure.contrib.base64/encode-str</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">sample-data</span><span class="p">))))</span>
</span><span class='line'><span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">get </span><span class="nv">clojure-contrib-data</span> <span class="mi">0</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">; Simple sanity check; take commons-codec output as canonical and</span>
</span><span class='line'><span class="c1">; verify that what our implementations generate match up with the</span>
</span><span class='line'><span class="c1">; canonical sample.</span>
</span><span class='line'><span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nf">.equals</span><span class="p">(</span><span class="nb">get </span><span class="nv">commons-codec-data</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">get </span><span class="nv">clojure-contrib-data</span> <span class="mi">0</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nb">println </span><span class="s">&quot;fencepost/base64_letfn&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">fencepost-data</span> <span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nf">vec</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nf">fencepost.base64_letfn/base64-encode-ascii</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">sample-data</span><span class="p">))))</span>
</span><span class='line'><span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">get </span><span class="nv">fencepost-data</span> <span class="mi">0</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nf">.equals</span> <span class="p">(</span><span class="nb">get </span><span class="nv">commons-codec-data</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">get </span><span class="nv">fencepost-data</span> <span class="mi">0</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>The following run is fairly representative:</p>

<pre><code>bartok ~/git/base64-clojure $ clojure fencepost/test/compare_base64.clj 
Commons-codec
"Elapsed time: 69.074926 msecs"
RFJlYWkqIF10RCc1PXlpO3FcIDY6dkJuQkhHNWxRJkwkOFdgciFGfHwhYz5EYG15PjxWdFJ9Ml83TGFoeltHSTs+ST9mdj0rfSZrcVNIKn5oKSdTI3U5a1FqIzBvIkRIV0BkK3xCZjtrSWYuTiM1XWB9UW14W2dVLFM=
clojure-contrib
"Elapsed time: 1221.124746 msecs"
RFJlYWkqIF10RCc1PXlpO3FcIDY6dkJuQkhHNWxRJkwkOFdgciFGfHwhYz5EYG15PjxWdFJ9Ml83TGFoeltHSTs+ST9mdj0rfSZrcVNIKn5oKSdTI3U5a1FqIzBvIkRIV0BkK3xCZjtrSWYuTiM1XWB9UW14W2dVLFM=
fencepost/base64_letfn
"Elapsed time: 375.829153 msecs"
RFJlYWkqIF10RCc1PXlpO3FcIDY6dkJuQkhHNWxRJkwkOFdgciFGfHwhYz5EYG15PjxWdFJ9Ml83TGFoeltHSTs+ST9mdj0rfSZrcVNIKn5oKSdTI3U5a1FqIzBvIkRIV0BkK3xCZjtrSWYuTiM1XWB9UW14W2dVLFM=
</code></pre>

<p>These results do confirm that that clojure-contrib implementation is very, very slow in relation to commons-codec. We&#8217;ve reduced that runtime by roughly a third but we&#8217;re still five or six times slower than commons-codec. Surely we can do better; in the next installment we&#8217;ll see how to do so.</p>

<p>As usual all code can be found on <a href="https://github.com/heuristicfencepost/base64-clojure">github</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/22/concurrent-prime-factorization-in-go/">Concurrent Prime Factorization in Go</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-22T12:00:00-05:00" pubdate data-updated="true">Oct 22<span>nd</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Originally published at <a href="http://heuristic-fencepost.blogspot.com/2010/10/concurrent-prime-factorization-in-go.html">Heuristic Fencepost</a></p>

<p>For a little while now I&#8217;ve been looking for a problem that would allow me to sink my teeth into <a href="http://golang.org">Google&#8217;s Go language</a> and see if it&#8217;s as tasty as it appears to be. After coming across Alex Tkachman&#8217;s <a href="https://profiles.google.com/113183999235628738153/buzz/J8oSTjegB5F">request for concurrency benchmarks</a> it was clear that I had what I needed. Alex is the driving force behind Groovy++ and his proposal was to implement a common benchmark (a concurrent version of prime factorization using the Sieve of Eratosthenes) in multiple JVM languages in order to compare and contrast what works and what doesn&#8217;t. An implementation in Go wouldn&#8217;t help much in benchmarking JVM languages but the highly concurrent nature of the problem does map naturally onto Go&#8217;s feature set. The language distribution also includes an elegant implementation of the Sieve of Eratosthenes in it&#8217;s tests so we already have a solid foundation to build from.</p>

<p>Let&#8217;s begin with sieve.go. The implementation consists of chained goroutines. Each time a candidate makes it through the sieve and is returned as a new prime number a new goroutine is created to check future candidates and reject them if they divide evenly by the new prime. The implementation cleanly demonstrates the concept but isn&#8217;t useful as a standalone application since it includes no termination condition. Let&#8217;s begin by adding that in:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="c1">// $G $F.go &amp;&amp; $L $F.$A  # don&#39;t run it - goes forever</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Copyright 2009 The Go Authors. All rights reserved.</span>
</span><span class='line'><span class="c1">// Use of this source code is governed by a BSD-style</span>
</span><span class='line'><span class="c1">// license that can be found in the LICENSE file.</span>
</span><span class='line'>
</span><span class='line'><span class="kn">package</span> <span class="nx">main</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="s">&quot;flag&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Send the sequence 2, 3, 4, ... to channel &#39;ch&#39;.</span>
</span><span class='line'><span class="kd">func</span> <span class="nx">Generate</span><span class="p">(</span><span class="nx">max</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>     <span class="c1">// Slight optimization; after 2 we know there are no even primes so we only</span>
</span><span class='line'>     <span class="c1">// need to consider odd values</span>
</span><span class='line'>     <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">2</span>
</span><span class='line'>     <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;=</span><span class="nx">max</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">{</span>
</span><span class='line'>       <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span> <span class="c1">// Send &#39;i&#39; to channel &#39;ch&#39;.</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// Use -1 as an indicator that we&#39;re done now</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Copy the values from channel &#39;in&#39; to channel &#39;out&#39;,</span>
</span><span class='line'><span class="c1">// removing those divisible by &#39;prime&#39;.</span>
</span><span class='line'><span class="kd">func</span> <span class="nx">Filter</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">prime</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">in</span><span class="p">;</span> <span class="nx">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">=</span> <span class="o">&lt;-</span> <span class="nx">in</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>       <span class="k">if</span> <span class="nx">i</span> <span class="o">%</span> <span class="nx">prime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">i</span> <span class="c1">// Send &#39;i&#39; to channel &#39;out&#39;.</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="nx">out</span> <span class="o">&lt;-</span> <span class="o">-</span><span class="mi">1</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// The prime sieve: Daisy-chain Filter processes together.</span>
</span><span class='line'><span class="kd">func</span> <span class="nx">Sieve</span><span class="p">(</span><span class="nx">max</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// Create a new channel.</span>
</span><span class='line'>     <span class="k">go</span> <span class="nx">Generate</span><span class="p">(</span><span class="nx">max</span><span class="p">,</span><span class="nx">ch</span><span class="p">)</span>      <span class="c1">// Start Generate() as a subprocess.</span>
</span><span class='line'>     <span class="k">for</span> <span class="nx">prime</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">;</span> <span class="nx">prime</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">prime</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="p">{</span>
</span><span class='line'>       <span class="nb">print</span><span class="p">(</span><span class="nx">prime</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">)</span>
</span><span class='line'>   <span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span><span class='line'>   <span class="k">go</span> <span class="nx">Filter</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">ch1</span><span class="p">,</span> <span class="nx">prime</span><span class="p">)</span>
</span><span class='line'>   <span class="nx">ch</span> <span class="p">=</span> <span class="nx">ch1</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>     <span class="kd">var</span> <span class="nx">max</span> <span class="o">*</span><span class="kt">int</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;max&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Maximum number we wish to return&quot;</span><span class="p">)</span>
</span><span class='line'>     <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
</span><span class='line'>     <span class="nx">Sieve</span><span class="p">(</span><span class="o">*</span><span class="nx">max</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<pre><code>[varese factorization_benchmark]$ cd go
[varese go]$ ls
factor.go  sieve.go
[varese go]$ gobuild sieve.go
Parsing go file(s)...
Compiling main (sieve)...
Linking sieve...
[varese go]$ ./sieve -max 20
2
3
5
7
11
13
17
19
</code></pre>

<p>That seemed to work nicely. Adding in the factorization code leads us to factor.go:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="c1">// Copyright 2009 The Go Authors. All rights reserved.</span>
</span><span class='line'><span class="c1">// Use of this source code is governed by a BSD-style</span>
</span><span class='line'><span class="c1">// license that can be found in the LICENSE file.</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Prime factorization derived from slightly modified version of</span>
</span><span class='line'><span class="c1">// sieve.go in Go source distribution.</span>
</span><span class='line'>
</span><span class='line'><span class="kn">package</span> <span class="nx">main</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>
</span><span class='line'><span class="kn">import</span> <span class="s">&quot;flag&quot;</span>
</span><span class='line'><span class="kn">import</span> <span class="nx">vector</span> <span class="s">&quot;container/vector&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Send the sequence 2, 3, 4, ... to channel &#39;ch&#39;.</span>
</span><span class='line'><span class="kd">func</span> <span class="nx">Generate</span><span class="p">(</span><span class="nx">max</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">ch</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>     <span class="c1">// Slight optimization; after 2 we know there are no even primes so we only</span>
</span><span class='line'>     <span class="c1">// need to consider odd values</span>
</span><span class='line'>     <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">2</span>
</span><span class='line'>     <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;=</span><span class="nx">max</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">{</span>
</span><span class='line'>       <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span> <span class="c1">// Send &#39;i&#39; to channel &#39;ch&#39;.</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// Use -1 as an indicator that we&#39;re done now</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Copy the values from channel &#39;in&#39; to channel &#39;out&#39;,</span>
</span><span class='line'><span class="c1">// removing those divisible by &#39;prime&#39;.</span>
</span><span class='line'><span class="kd">func</span> <span class="nx">Filter</span><span class="p">(</span><span class="nx">in</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">out</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">prime</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">in</span><span class="p">;</span> <span class="nx">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">=</span> <span class="o">&lt;-</span> <span class="nx">in</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>       <span class="k">if</span> <span class="nx">i</span> <span class="o">%</span> <span class="nx">prime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">out</span> <span class="o">&lt;-</span> <span class="nx">i</span> <span class="c1">// Send &#39;i&#39; to channel &#39;out&#39;.</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="nx">out</span> <span class="o">&lt;-</span> <span class="o">-</span><span class="mi">1</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>     <span class="kd">var</span> <span class="nx">target</span> <span class="o">*</span><span class="kt">int</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">Int</span><span class="p">(</span><span class="s">&quot;target&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;Number we wish to factor&quot;</span><span class="p">)</span>
</span><span class='line'>     <span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>     <span class="nx">t</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">target</span>
</span><span class='line'>     <span class="kd">var</span> <span class="nx">rv</span> <span class="nx">vector</span><span class="p">.</span><span class="nx">IntVector</span>
</span><span class='line'>
</span><span class='line'>     <span class="c1">// Retrieve a prime value and see if we can divide the target evenly by</span>
</span><span class='line'>     <span class="c1">// that prime.  If so perform the multiplication and update the current</span>
</span><span class='line'>     <span class="c1">// value.</span>
</span><span class='line'>     <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// Create a new channel.</span>
</span><span class='line'>     <span class="k">go</span> <span class="nx">Generate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span><span class="nx">ch</span><span class="p">)</span>      <span class="c1">// Start Generate() as a subprocess.</span>
</span><span class='line'>     <span class="k">for</span> <span class="nx">prime</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">;</span> <span class="p">(</span><span class="nx">prime</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">t</span> <span class="p">&gt;</span> <span class="mi">1</span><span class="p">);</span> <span class="nx">prime</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">for</span> <span class="p">;</span><span class="nx">t</span> <span class="o">%</span> <span class="nx">prime</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">{</span>
</span><span class='line'>          <span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span> <span class="o">/</span> <span class="nx">prime</span>
</span><span class='line'>      <span class="nx">rv</span><span class="p">.</span><span class="nx">Push</span><span class="p">(</span><span class="nx">prime</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Create a goroutine for each prime number whether we use it or</span>
</span><span class='line'>  <span class="c1">// not.  This performs the daisy chaining setup that was being</span>
</span><span class='line'>  <span class="c1">// done by the Sieve() function in sieve.go.</span>
</span><span class='line'>        <span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</span><span class='line'>        <span class="k">go</span> <span class="nx">Filter</span><span class="p">(</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">ch1</span><span class="p">,</span> <span class="nx">prime</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">ch</span> <span class="p">=</span> <span class="nx">ch1</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>     <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Results: %s\n&quot;</span><span class="p">,</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprint</span><span class="p">(</span><span class="nx">rv</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Simple enough. This leaves us with something that looks fairly robust:</p>

<pre><code>[varese go]$ gobuild factor.go 
Parsing go file(s)...
Compiling main (factor)...
Linking factor...
[varese go]$ ./factor -target 60
Results: [2 2 3 5]
</code></pre>

<p>Examples here employ <a href="http://code.google.com/p/gobuild">gobuild</a>. This tool has proven to be very useful when building and testing Go applications. Complete code for both examples can be found on <a href="https://github.com/heuristicfencepost/factorization_benchmark">github</a>. There is some interest in comparing a solution based on goroutines and channels to one based on actors and messages so in the future some Scala code might join the existing Go code.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/10/default-arguments-and-implicit-conversions-in-scala/">Default Arguments and Implicit Conversions in Scala</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-10T12:00:00-05:00" pubdate data-updated="true">Oct 10<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Originally published at <a href="http://heuristic-fencepost.blogspot.com/2010/10/default-arguments-and-implicit.html">Heuristic Fencepost</a></p>

<p>In a <a href="blog/2010/08/23/learning-scala-from-dead-swiss-mathematicians-return-of-palindromes/">previous post</a> we went in search of an implicit conversion from Int to List[Int] such that each member of the list corresponds to the value at an equivalent position in the input Int (i.e. 987 = List(9,8,7)). At the time we mentioned that a properly tail recursive implementation proved to be a bit more complicated than one might expect. In this post we&#8217;ll examine these problems in some detail.</p>

<p>A properly tail recursive implementation of this conversion function makes use of an accumulator array to store state as we recurse.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">package</span> <span class="nn">org.fencepost.defaults</span>
</span><span class='line'>
</span><span class='line'><span class="k">import</span> <span class="nn">org.scalatest.Suite</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">ImplicitDefaultTest1</span> <span class="k">extends</span> <span class="nc">Suite</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">int2list</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> <span class="n">acc</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="n">newmember</span> <span class="k">=</span> <span class="n">arg</span> <span class="o">%</span> <span class="mi">10</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">arg</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="o">)</span>
</span><span class='line'>      <span class="nc">List</span><span class="o">(</span><span class="n">newmember</span><span class="o">)</span> <span class="o">:::</span> <span class="n">acc</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="n">int2list</span><span class="o">(</span><span class="n">arg</span> <span class="o">/</span> <span class="mi">10</span><span class="o">,</span><span class="nc">List</span><span class="o">(</span><span class="n">newmember</span><span class="o">)</span> <span class="o">:::</span> <span class="n">acc</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">def</span> <span class="n">toList</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">int2list</span><span class="o">(</span><span class="n">arg</span><span class="o">,</span><span class="nc">List</span><span class="o">())</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">testImplicit</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mf">0.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">0</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mf">5.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">5</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mf">12345.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">12345</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">12345</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">12345</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mf">98765432.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">8</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">98765432</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The test above passes so everything looks good so far. On a second look, however, we note that the wrapper function toList() is less than ideal. The accumulator needs to be initialized to the empty list in order for the function to work correctly but defining a second function just to pass in an extra arg looks like unnecessary cruft. Scala 2.8 introduced default arguments to address situations such as this; perhaps we can deploy default arguments here to clean up our test:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">package</span> <span class="nn">org.fencepost.defaults</span>
</span><span class='line'>
</span><span class='line'><span class="k">import</span> <span class="nn">org.scalatest.Suite</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">ImplicitDefaultTest2</span> <span class="k">extends</span> <span class="nc">Suite</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">def</span> <span class="n">int2list</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> <span class="n">acc</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">())</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="n">newmember</span> <span class="k">=</span> <span class="n">arg</span> <span class="o">%</span> <span class="mi">10</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">arg</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="o">)</span>
</span><span class='line'>      <span class="nc">List</span><span class="o">(</span><span class="n">newmember</span><span class="o">)</span> <span class="o">:::</span> <span class="n">acc</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="n">int2list</span><span class="o">(</span><span class="n">arg</span> <span class="o">/</span> <span class="mi">10</span><span class="o">,</span><span class="nc">List</span><span class="o">(</span><span class="n">newmember</span><span class="o">)</span> <span class="o">:::</span> <span class="n">acc</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">testImplicit</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mf">0.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">0</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mf">5.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">5</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mf">12345.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">12345</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">12345</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">12345</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mf">98765432.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">8</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">98765432</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>When we attempt to execute the test above we&#8217;re greeted rather rudely by sbt:</p>

<pre><code>[info] Compiling test sources...
[error] .../src/test/scala/org/fencepost/defaults/ImplicitDefaultTest2.scala:21:
 value length is not a member of Int
[error]     assert(0.length == 1)
[error]              ^
[error] .../src/test/scala/org/fencepost/defaults/ImplicitDefaultTest2.scala:22:
 0 of type Int(0) does not take parameters
[error]     assert(0(0) == 0)
...
</code></pre>

<p>Clearly the implicit conversion of Int to List[Int] wasn&#8217;t in play when this test was executed. But why not? Logically int2list(arg:Int, acc:List[Int] = List()) will convert Ints to List[Int] everywhere int2list(arg:Int, acc:List[Int]) does. We can demonstrate the validity of this claim by fooling the compiler using a variation on the front-end function we used before:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">package</span> <span class="nn">org.fencepost.defaults</span>
</span><span class='line'>
</span><span class='line'><span class="k">import</span> <span class="nn">org.scalatest.Suite</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">ImplicitDefaultTest3</span> <span class="k">extends</span> <span class="nc">Suite</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">int2list</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> <span class="n">acc</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">())</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="n">newmember</span> <span class="k">=</span> <span class="n">arg</span> <span class="o">%</span> <span class="mi">10</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">arg</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="o">)</span>
</span><span class='line'>      <span class="nc">List</span><span class="o">(</span><span class="n">newmember</span><span class="o">)</span> <span class="o">:::</span> <span class="n">acc</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="n">int2list</span><span class="o">(</span><span class="n">arg</span> <span class="o">/</span> <span class="mi">10</span><span class="o">,</span><span class="nc">List</span><span class="o">(</span><span class="n">newmember</span><span class="o">)</span> <span class="o">:::</span> <span class="n">acc</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">def</span> <span class="n">toList</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">int2list</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">testImplicit</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mf">0.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">0</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mf">5.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">5</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mf">12345.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">12345</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">12345</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">12345</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mf">98765432.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">8</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="mi">98765432</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>As expected this test passes without issue.</p>

<p>My suspicion is that this issue is a side effect of the fact that default arguments apparently aren&#8217;t represented in the type system. It&#8217;s not surprising that int2list(arg:Int, acc:List[Int]) isn&#8217;t available as an implicit conversion; there&#8217;s no way for the runtime to supply the required &#8220;acc&#8221; argument for an input Int instance. This is not true for int2list(arg:Int, acc:List[Int] = List()); in that case the default value of &#8220;acc&#8221; could be used to perform the translation. Note, however, that these two functions are represented by the same type in the Scala runtime:</p>

<pre><code>$ scala
Welcome to Scala version 2.8.0.final (OpenJDK Client VM, Java 1.6.0_18).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt;   def int2list(arg:Int, acc:List[Int]):List[Int] = {
...
int2list: (arg: Int,acc: List[Int])List[Int]

scala&gt;   def int2list2(arg:Int, acc:List[Int] = List()):List[Int] = {
...
int2list2: (arg: Int,acc: List[Int])List[Int]
</code></pre>

<p>If the type system is unaware that default arguments are available for all arguments other than the type to convert from then it&#8217;s not at all surprising that a function would be excluded from the set of valid implicit conversion functions.</p>

<p>Results tested and verified on both Scala 2.8.0 and 2.8.1 RC2.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/23/learning-scala-from-dead-swiss-mathematicians-return-of-palindromes/">Learning Scala From Dead Swiss Mathematicians : Return of Palindromes</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-08-23T12:00:00-05:00" pubdate data-updated="true">Aug 23<span>rd</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Originally published at <a href="http://heuristic-fencepost.blogspot.com/2010/08/learning-scala-from-dead-swiss.html">Heuristic Fencepost</a></p>

<p>In a <a href="blog/2010/07/26/learning-scala-from-dead-swiss-mathematicians-palindromes/">recent post</a> we implemented a predicate to identify integers which were also palindromes. Our original implementation converted the input integer to a String in order to more easily access the leading digit, something that can&#8217;t easily be done with an input integer. But is this really the case?</p>

<p>If we could easily convert Integers into a List[Integer] [1] we could then easily access the &#8220;head&#8221; and &#8220;tail&#8221; of this list for purposes of comparison. Ideally this conversion could be automated so that we don&#8217;t have to explicitly track these conversions. Fortunately Scala&#8217;s implicit conversions provide exactly these features. A simple implementation looks something like the following:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">implicit</span> <span class="k">def</span> <span class="n">int2list</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">arg</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="o">)</span>
</span><span class='line'>    <span class="nc">List</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="n">int2list</span><span class="o">(</span><span class="n">arg</span> <span class="o">/</span> <span class="mi">10</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="n">arg</span> <span class="o">%</span> <span class="mi">10</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>It&#8217;s worth taking a moment to point out a few things about this function:</p>

<ul>
<li>We&#8217;re assuming base 10 integers here. We could make the function more flexible by adding a parameter to specify the integers base if necessary</li>
<li>A better implementation would be purely tail recursive, but this turns out to be a bit trickier than expected; more on that in a future post.</li>
</ul>


<p>With this conversion in place we can now define a properly tail recursive predicate to check for palindromes:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">byInt</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span><span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">arg</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">arg</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">arg</span><span class="o">.</span><span class="n">head</span> <span class="o">!=</span> <span class="n">arg</span><span class="o">.</span><span class="n">last</span><span class="o">)</span>
</span><span class='line'>    <span class="kc">false</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="n">byInt</span><span class="o">(</span><span class="n">arg</span><span class="o">.</span><span class="n">slice</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">arg</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Very nice, but Scala&#8217;s pattern matching allows for an even better (by which we mean &#8220;simpler&#8221;) implementation that makes use of pattern guards:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">byIntMatch</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span><span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Note that we don&#39;t need to check for lists of length </span>
</span><span class='line'>  <span class="c1">// 0 or length 1 as we do in byInt above.  The first </span>
</span><span class='line'>  <span class="c1">// two cases of our match operation below handle these </span>
</span><span class='line'>  <span class="c1">// cases.</span>
</span><span class='line'>  <span class="n">arg</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="kc">true</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">arghead</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">last</span> <span class="o">==</span> <span class="n">arghead</span> <span class="k">=&gt;</span> <span class="n">byIntMatch</span><span class="o">(</span><span class="n">rest</span><span class="o">.</span><span class="n">slice</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">rest</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span>
</span><span class='line'>    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The full implementation can be found at <a href="https://github.com/heuristicfencepost/euler">github</a>. Most of the code discussed here can be found in the org.fencepost.palindrome package; a full solution to Problem 4 using this code is also included.</p>

<p>[1] We use integers here only as a matter of convenience; of course we really only need a Byte as long as we&#8217;re talking about base 256 or less. We can always optimize for space later if needed.</p>

<p>UPDATE - Shortly after completing this post I began another chapter in the &#8220;stairway&#8221; book. That chapter (covering details of the implementation of the List class in Scala) promptly pointed out that the list concatenation operator executes in time proportional to the size of the operand on the left. In order to avoid the performance hit we shift to an approach based on iteration and mutation.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">implicit</span> <span class="k">def</span> <span class="n">int2list</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">val</span> <span class="n">buff</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">counter</span> <span class="k">=</span> <span class="n">arg</span>
</span><span class='line'>  <span class="k">while</span> <span class="o">(</span><span class="n">counter</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">buff</span> <span class="o">+=</span> <span class="o">(</span><span class="n">counter</span> <span class="o">%</span> <span class="mi">10</span><span class="o">)</span>
</span><span class='line'>    <span class="n">counter</span> <span class="k">=</span> <span class="o">(</span><span class="n">counter</span> <span class="o">/</span> <span class="mi">10</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="n">buff</span> <span class="o">+=</span> <span class="n">counter</span>
</span><span class='line'>  <span class="n">buff</span> <span class="n">toList</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The process for choosing when to use an iterative approach over a functional approach is still somewhat opaque. Scala has an explicit bias in favor of functional methods yet in many cases (including this one) an iterative implementation is the correct one to use. Presumably identifying when to use which approach is largely a function of experience with the language.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/07/26/learning-scala-from-dead-swiss-mathematicians-palindromes/">Learning Scala From Dead Swiss Mathematicians : Palindromes</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-07-26T12:00:00-05:00" pubdate data-updated="true">Jul 26<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Originally published at <a href="http://heuristic-fencepost.blogspot.com/2010/07/learning-scala-from-dead-swiss.html">Heuristic Fencepost</a></p>

<p>As part of my effort to get up to speed with Scala I returned to an old favorite for exploring new languages; working through some of the problems at <a href="http://projecteuler.net">Project Euler</a>. Posting complete answers to specific problems isn&#8217;t terribly interesting and I have no plans to do so here. That said, some facets of these problems do lead to useful digressions which allow for a deeper exploration of the language. We&#8217;ll dig into one such example here.</p>

<p>The problem under consideration is Problem 4 which asks for &#8220;the largest palindrome made from the product of two 3-digit numbers&#8221;. It doesn&#8217;t take much imagination to determine that part of the solution will involve a method, most likely a function of some kind, for identifying whether a number is in fact a palindrome. Okay, but what would such a method look like? The problem lends itself to a simple recursive implementation: divide the integer into a leading digit, a middle integer and a trailing digit and return false if the leading and trailing digits differ, otherwise return the result of the a recursive call with the middle integer.</p>

<p>Easy enough, but a moments reflection tells us we have a problem; we can access the trailing digit in an integer using the mod function and the base of the input integer but there&#8217;s no easy way to access the leading digit. It&#8217;s not as if Int (or even RichInt) extend Seq[Int] or even Seq[Byte]. Fortunately we can shift the problem domain by observing that an input integer is equivalent to an input String in which each digit of the integer maps to a Char in the String. Even better, Scala offers built-in support for regular expressions, and a fairly simple regex should give us access to both the leading and trailing characters and everything in the middle. So, how does Scala&#8217;s regex support stack up?</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// Pattern to be used by the regex-based predicate.  </span>
</span><span class='line'><span class="c1">// Absolutely must use conservative matching and </span>
</span><span class='line'><span class="c1">// the backref here to make this work.</span>
</span><span class='line'><span class="k">val</span> <span class="n">palindromePattern</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;(\d)(\d*?)\1&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Recursive helper function to check for a </span>
</span><span class='line'><span class="c1">//palindrome using a regex</span>
</span><span class='line'><span class="k">def</span> <span class="n">byRegexHelper</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Base case; empty string and single characters </span>
</span><span class='line'>  <span class="c1">// are by definition palindromes.  Place this </span>
</span><span class='line'>  <span class="c1">// test up front so that we can handle input values</span>
</span><span class='line'>  <span class="c1">// of a single character.</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span>
</span><span class='line'>  <span class="n">palindromePattern</span><span class="o">.</span><span class="n">unapplySeq</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">matches</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">byRegexHelper</span><span class="o">(</span><span class="n">matches</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="kc">false</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Regex-based predicate; convert to a string and call</span>
</span><span class='line'><span class="c1">// the recrusive function</span>
</span><span class='line'><span class="k">def</span> <span class="n">byRegex</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">Boolean</span> <span class="o">=</span> <span class="n">byRegexHelper</span><span class="o">(</span><span class="n">arg</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Not bad, actually. It&#8217;s not Perl or Ruby but the deep support for pattern matching in the language combined with relatively easy generation of a Regex from a String makes for a fairly clean syntax. Regex literals would be a small improvement but this is still cleaner than what one finds in Java or even Python.</p>

<p>So we&#8217;ve solved the problem, but can we do better? Do we really need the regex? Strings (or the StringOps they&#8217;re implicitly converted to in 2.8) make use of the SeqLike[Char] trait allowing easy access to the leading and trailing characters using simple method calls. This leads to the following implementation which avoids the overhead of evaluating the regular expression:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// Recursive helper function to perform the check </span>
</span><span class='line'><span class="c1">// based on comparisons of the head and last </span>
</span><span class='line'><span class="c1">// characters in a string</span>
</span><span class='line'><span class="k">def</span> <span class="n">byStringHelper</span><span class="o">(</span><span class="n">n</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Base case; empty string and single characters</span>
</span><span class='line'>  <span class="c1">// are by definition palindromes.  Place this test</span>
</span><span class='line'>  <span class="c1">// up front so that we can handle input values of</span>
</span><span class='line'>  <span class="c1">// a single character.</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">n</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">head</span> <span class="o">!=</span> <span class="n">n</span><span class="o">.</span><span class="n">last</span><span class="o">)</span>
</span><span class='line'>    <span class="kc">false</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="n">byStringHelper</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">n</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// String-based predicate; convert to string and call</span>
</span><span class='line'><span class="c1">// the recursive function</span>
</span><span class='line'><span class="k">def</span> <span class="n">byString</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">Boolean</span> <span class="o">=</span> <span class="n">byStringHelper</span><span class="o">(</span><span class="n">arg</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Also not bad, but still not completely satisfying. Moving away from the use of regular expressions minimizes the benefit of mapping the input integer onto a String in order to solve the problem. Recall that the primary argument for doing so was the inability to access leading digits in an input integer. How significant is this constraint? Is it something we can work around? More on this next time.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/07/10/ruby-perl-and-eloquence/">Ruby, Perl and Eloquence</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/01/05/ruby-and-concurrency-design-with-actors-and-akka/">Ruby and Concurrency: Design with Actors and Akka</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/11/25/musings-on-list-comprehensions-functional-programming-and-python/">Musings on List Comprehensions, Functional Programming and Python</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/09/12/ruby-and-concurrency-the-mechanics-of-akka-and-jruby/">Ruby and Concurrency: The Mechanics of Akka and JRuby</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/09/02/cassandra-and-clojure-things-to-bytes-and-back-again/">Cassandra and Clojure: Things To Bytes And Back Again</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/absurdfarce">@absurdfarce</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'absurdfarce',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Bret McGuire -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
